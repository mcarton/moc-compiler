\documentclass{scrartcl}
\usepackage[utf8x]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{amssymb}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{minted}

\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{\headrulewidth}

\title{Rapport projet de TDL}
\author{Maxence Ahlouche \and Martin Carton \and Clément Hubin-Andrieu}
\date{mai 2014}

\newcommand{\mocc}{\texttt{mocc}}
\newcommand{\llvm}{\textit{llvm}}
\newcommand{\tam} {\textit{tam}}
\newminted[moccode]{cpp}{%
  tabsize=4, fontsize=\footnotesize,
  frame=lines, framesep=\fboxsep,
  rulecolor=\color{gray!40}
}

\begin{document}
  \maketitle
  \tableofcontents
  \newpage

\section{Introduction}
  Nous avons décider de compiler en \tam{} et en langage intermédiaire \llvm{}.
  De plus les interfaces devraient être suffisamment génériques pour permettre
  de compiler dans n'importe quel langage. Pour utiliser la machine \llvm{}, il
  suffit d'appeler le script \texttt{mocc} avec l'option \verb+-m llvm+ (la
  machine \tam{} est la machine par défaut).

  La compilation en langage intermédiaire \llvm{} nous permet de générer des
  exécutables natifs utilisant la \textit{libc} bien plus facilement, et de
  manière plus portable que ne l'aurait été la génération en directement en
  \textit{x86}. De plus le langage étant plus expressif (il est notamment typé),
  il permet de trouver plus facilement les erreurs éventuelles. Enfin il nous
  permet de bénéficier des différentes passes d'optimisation du compilateur
  \verb+llc+.

  Nous avons donc supprimé l'assembleur en-ligne tel qu'il était fourni (dans
  \verb+ASM.egg+), et rajouté une instruction \verb+asm+ qui prend une chaine
  de caractères, ce qui permet d'inclure de l'assembleur \llvm{} ou \tam{}
  selon la machine cible voulue. Il n'y a pour l'instant aucun moyen d'utiliser
  les variables définies en moc dans cet assembleur autrement qu'avec leur
  adresse.

  \paragraph{}
  \tam{} a cependant plusieurs avantages par rapport à \llvm{}: pour commencer
  \llvm{} est beaucoup plus expressif et typé: c'est souvent un avantage, mais
  rend parfois certaines tâches très complexe (par exemple la gestion de la
  \textit{vtable}, il est aussi nécessaire de préciser le type des variables et
  registres à chaque utilisation (et non déclaration), ce qui est très
  répétitif).

  Ensuite le nombre d'instructions très réduit de \tam{} rend la machine \tam{}
  relativement simple, alors que la machine \llvm{} est bien plus complexe.

  Enfin la possibilité de voir l'évolution de la pile et du tas instruction par
  instruction est un gros avantage de \tam{}. Pour pouvoir débugger la machine
  \llvm{} il aurait fallut ajouter les informations de débuggage au fichier
  construit, rendant la machine encore plus complexe.

\section{Tests}
  Nous avons écrit beaucoup de tests. Il y en a 4 types (tous dans le
  dossier \verb+tests+):
  \begin{itemize}
    \item ceux des dossiers \verb+success+, \verb+warning+, \verb+failure+
      testent l'analyse syntaxique et sémantique du compilateur (respectivement
      que le code est correct, qu'il génère un warning ou qu'il génère une
      erreur). Ces exemples ne font rien de particulier;
    \item ceux du dossier \verb+runnable+ testent le code généré, les exemples
      sont compilés par \mocc{} puis doivent être compilés avec \verb+llc+
      ou lancés dans \verb+tam+ et lancés.

      La sortie attendue pour le programme \verb+exemple.moc+ se trouve dans
      le fichier \verb+exemple.moc.output+.

      Ces fichiers nécessitent d'être préprocessés avant d'être compilés afin
      d'y inclure les fonctions d'affichages spécifique à \llvm{} ou \tam{}
      (écrites en assembleur).

      Les scripts \verb+tests/run-llvm+ et \verb+tests/run-tam+ permettent de
      préprocesser, compiler et lancer ces tests.
  \end{itemize}

\section{Extensions du langage}
  \subsection{Asm}
    Comme indiqué dans l'introduction, nous avons remplacé l'instruction
    \verb+asm+ fournie par une instruction plus simple prenant une chaine de
    caractère.

    \begin{moccode}
// en llvm:
void put_char(Char c) {
    asm("%1 = load i8* %c.0, align 1");
    asm("%2 = sext i8 %1 to i32");
    asm("%3 = call i32 @putchar(i32 %2)");
}

// en tam:
void put_char(Char c) {
    asm("LOAD (1) -1[LB]");
    asm("SUBR COut");
}
    \end{moccode}

    Il n'est pas possible d'utiliser les variables autrement que par leur
    adresse. Vu le peu d'assembleur en-ligne que nous utilisons, nous n'avons
    pas jugé qu'ajouter la possibilité d'utiliser des variables par leur nom en
    valait la peine.

  \subsection{Alias de type}\label{alias}
    Il est possible de définir des alias de type:
    \begin{moccode}
using NouveauNom = NomExistant;
    \end{moccode}

    La syntaxe évite volontairement le \verb+typedef+ bizarre du C.

  \subsection{Tableaux}\label{tab}
    On peut créer des tableaux:
    \begin{moccode}
Char[5] s = "net7";
    \end{moccode}

    La taille se met après le type, et non le nom comme en C.

    Ils sont convertibles en pointeurs vers le type correspondant, mais le font
    dans moins de cas qu'en C (notamment les tableaux sont copiables,
    passables comme paramètre de fonction et peuvent être retournés). Le type
    tableau est un vrai type.

  \subsection{Opérateurs new et delete}\label{new}
    Ces opérateurs sont équivalents à \verb+malloc+ et \verb+free+, mais sont
    typés (le langage ne possède pas de type \verb+void*+).

    \begin{moccode}
Int* taille = new(Int);
*taille = 10;

Char* test = new[*taille](Char);
delete(taille);
delete(test);
    \end{moccode}

    L'opérateur \verb+new+ a aussi l'avantage de tenir compte de la taille et
    d'initialiser la \textit{vtable}.

  \subsection{Opérateur sizeof}
    Cet opérateur retourne la taille d'un type:

    \begin{moccode}
Int a = sizeof(Int); // 1 en tam, 8 en llvm sur une machine 64bits
    \end{moccode}

    Il tient compte de la \textit{vtable} dans le cas des classes.

  \subsection{Boucle}
    Nous avons ajouté une boucle \verb+while+.

\section{Design decisions}
  \subsection{Typage}
    Le typage est plus fort qu'en C.

    En particulier, il n'y a pas de type \verb+void*+, ce qui empêche notamment
    d'écrire une fonction comme \verb+malloc+, mais nous avons ajouté un
    opérateur \verb+new+ (voir section~\ref{new}).

    Le typage des tableaux (voir section~\ref{tab}) est aussi plus fort qu'en C.

    \subsubsection{Conversions}
      Il a deux types de casts: implicites et explicites.

      TODO: raconter des trucs ici

  \subsection{Noms de types}
    Les noms de type commencent tous par une majuscule. Ceci afin de permettre
    d'avoir des alias de type (voir section~\ref{alias}) et par uniformité avec
    les nom de classes.

    Cette restriction permet de désambiguïser une instruction comme
    \verb+a*b;+ qui pourrait être interprétée comme la multiplication de
    \verb+a+ et \verb+b+ ou la déclaration d'un pointeur \verb+b+ de type
    \verb+a*+.

  \subsection{\texttt{NULL} et \texttt{nil}, \texttt{YES} et \texttt{NO}}
    Il n'y a pas de \verb+nil+ (qui serait inutile vu qu'il n'y aurait pas de
    différence avec \verb+NULL+) et \verb+NULL+ s'écrit \verb+null+ par
    consistance avec les autres variables.

    De même \verb+YES+ et \verb+NO+ s'écrivent \verb+yes+ et \verb+no+.

  \subsection{Classes}
    Nous avons supprimé le \verb+@+ devant \verb+@class+. Les méthodes se
    mettent entre les accolades, après les attributs; il n'y a donc plus de
    \verb+@end+.

    Par exemple:
    \begin{moccode}
class Point {
    Int x;
    Int y;

    +(void) init {
    }

    -(Int) x {
        return 0;
    }

    -(Int) y {
        return 0;
    }
}
    \end{moccode}

\section{Warnings}
  Nous avons ajouté des warnings au compilateur.

  Il suffit d'appeler \mocc{} avec \verb+-w nom_du_warning+.
  Il y a aussi un warning \verb+all+.

  \subsection{unreachable}
    \verb"unreachable" vérifie la présence d'instructions inutiles.

    Par exemple:
    \begin{moccode}
Int test() {
    [...]

    if(a) {
        return 123;
    }
    else {
        return 456;
    }
    f(); // unreachable
}
    \end{moccode}

  \subsection{shadow}
    \verb"shadow" vérifie qu'une déclaration ne masque pas une déclaration
    précédente, par exemple:
    \begin{moccode}
Int test() {
    Int a;

    if(a) {
        Char a; // shadow
    }
}
    \end{moccode}
\end{document}

