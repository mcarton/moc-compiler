option version = 1.0.1 ;
option k = 2;
option auto = true;

-- attributs
syn code_asm :STRING  for TAM, INST, CINST, ADR, INSTS, CSTE;
inh tds_asm : TDS for TAM, INST, INSTS, ADR, CSTE;

space  separ  is "[\t ]+";
sugar  colon  is "\:";
sugar  osbra  is "\[";
sugar  csbra  is "\]";
sugar  opar   is "\(";
sugar  cpar   is "\)";
sugar  ocbra  is "\{";
sugar  ccbra  is "\}";
sugar  load   is "LOAD";
sugar  loada  is "LOADA";
sugar  loadi  is "LOADI";
sugar  loadl  is "LOADL";
sugar  store  is "STORE";
sugar  storei is "STOREI";
sugar  call   is "CALL";
sugar  calli  is "CALLI";
sugar  return is "RETURN";
sugar  subr   is "SUBR";
sugar  push   is "PUSH";
sugar  pop    is "POP";
sugar  jump   is "JUMP";
sugar  jumpi  is "JUMPI";
sugar  jumpif is "JUMPIF";
sugar  halt   is "HALT";
sugar  nl     is "(\n|\r)";
term   string is "\"([^\"]|\\.)*\"";
term   char   is "\'([^\']|\\.)\'";
term   nb     is "\-?[0-9]+";
term   var    is "%[A-Za-z][A-Za-z0-9_]*"; -- pour designer une variable de MC
term   ident  is "[0-9a-zA-Z_\$@#\.\?\<\>]+";
term   info   is "\;[^\n\r]*";

TAM -> ocbra INSTS ccbra #gen; #gen { TAM^code_asm = "; inline code_asm\n" + INSTS^code_asm; }

INSTS -> INST INSTS #gen; #gen { INSTS^code_asm =   INST^code_asm + "\n" + INSTS1^code_asm; }

INSTS -> #gen; #gen { INSTS^code_asm = ""; }

ADR -> opar nb cpar nb osbra ident csbra  #gen; #gen { ADR^code_asm = "(" + nb^txt + ") " + nb^txt + '[' + ident^txt+ ']'; }

ADR -> var  #gen;
#gen {
    INFO i;
    INFOVAR v;
    Location e;
    Register r;
    DTYPE t;

    -- remplace var^txt par l'emplacement de la variable
    if(ADR^tds_asm == null) {
        -- write "pas de TDS\n"
    }
    else {
        i = ADR^tds_asm.globalSearch(var^txt.substring(1));
        if(i /= nil) {
            match(i) {
                case INFOVAR {
                    v = i;
                    t = v.getType();
                    e = v.getEmpl();
                    r = e.getReg();
                    ADR^code_asm =
                        "("+ t.getSize() + ") "
                      + e.getDep()
                      + "["+ r.getName()+ "]";
                }
                default {
                    error(NOT_A_VAR, var^txt);
                }
            }
        }
        else {
            error(UNKNOWN, var^txt);
        }
    }
}

INST -> nl #gen; #gen { INST^code_asm = "\n"; }

INST -> info nl #gen; #gen { INST^code_asm = "\t" + info^txt + "\n"; }

INST -> load ADR #gen; #gen { INST^code_asm = "\tLOAD "+ ADR^code_asm; }

INST -> loada CINST #gen; #gen { INST^code_asm = "\tLOADA " + CINST^code_asm; }

INST -> loadi opar nb cpar #gen; #gen { INST^code_asm = "\tLOADI (" + nb^txt + ")"; }

INST -> loadl CSTE #gen; #gen { INST^code_asm = "\tLOADL " + CSTE^code_asm; }

CSTE -> nb #gen; #gen { CSTE^code_asm = nb^txt; }

CSTE -> string #gen; #gen { CSTE^code_asm = string^txt; }

CSTE -> char #gen; #gen { CSTE^code_asm = char^txt; }

INST -> store ADR #gen; #gen { INST^code_asm = "\tSTORE " + ADR^code_asm; }

INST -> storei opar nb cpar #gen; #gen { INST^code_asm = "\tSTOREI (" + nb^txt + ")"; }

INST -> call opar ident cpar CINST #gen; #gen { INST^code_asm = "\tCALL (" + ident^txt + ") " + CINST^code_asm; }

INST -> calli #gen; #gen { INST^code_asm = "\tCALLI"; }

INST -> return opar nb cpar nb #gen; #gen { INST^code_asm = "\tRETURN (" + nb^txt + ") " + nb1^txt; }

INST -> subr ident #gen; #gen { INST^code_asm = "\tSUBR " + ident^txt; }

INST -> ident #gen; #gen { INST^code_asm = ident^txt; }

INST -> push nb #gen; #gen { INST^code_asm = "\tPUSH " + nb^txt; }

INST -> pop opar nb cpar nb #gen; #gen { INST^code_asm = "\tPOP (" + nb^txt + ") " + nb1^txt; }

INST -> jump CINST #gen; #gen { INST^code_asm = "\tJUMP " + CINST^code_asm; }

INST -> jumpi #gen; #gen { INST^code_asm = "\tJUMPI"; }

INST -> jumpif opar nb cpar CINST #gen; #gen { INST^code_asm = "\tJUMPIF (" + nb^txt +") " + CINST^code_asm; }

INST -> halt #gen; #gen { INST^code_asm = "\tHALT"; }

CINST -> nb osbra ident csbra #gen; #gen { CINST^code_asm = nb^txt + '[' + ident^txt+ ']'; }

CINST -> ident #gen; #gen { CINST^code_asm = ident^txt; }
