-----------------------------------------------------
-- MC and MOC grammars                             --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k = 2;

-- the source file
inh source : MOCSourceFile for PROGRAM;
-- the target machine for code generation
inh machine : IMachine for
    ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
    FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS,ARGSX,
    E, EX, A, AX, R, RX, T, TX, F,
    REFS, STYPE, TYPE
-- TODO:MOC:
--       ,IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS,
--       MFUNC_PARAMETER, MFUNC_PARAMETERS,MARG, MARGS
;

-- these attributes allow to get ASM inline
syn code_asm : STRING for ASM;

-- the current symbols table
inh tds_asm : TDS for ASM;
inh tds : TDS for
    ENTITIES, BLOC, ELSE, INST, INSTS, ARGS, ARGSX,
    FUNCTION, FUNC_PARAMETER, FUNC_PARAMETERS, FUNC_PARAMETERSX,
    TYPE, STYPE,
    F, TX, T, RX, R, AX, A, EX, E
;

-- 0 => empty statement, 1 => non-empty but does not return, 2 => returns
syn returns : int for
    INST, INSTS, BLOC, ELSE;

-- types:
syn type : DTYPE for
    TYPE, STYPE, REFS,
    F, TX, T, RX, R, AX, A, EX, E
;
inh htype : DTYPE for
    REFS,
    TX, RX, AX
;
inh types : LTYPES for
    FUNC_PARAMETERS, FUNC_PARAMETERSX, FUNC_PARAMETER,
    ARGS, ARGSX
;
syn sym : String for OPREL;

--terminals
space separator    is "[\r\n\t ]+";
comment comm       is "\/\/[^\n]*\n";
comment ml_comm    is "\/\*([^\*]|(\*+[^\*\-]))*\*+\/";
sugar opar         is "\(";
sugar cpar         is "\)";
sugar occbra       is "\{";
sugar ccbra        is "\}";
sugar comma        is ",";
sugar semicolumn   is "\;";
sugar affect       is "=";
sugar if           is "if";
sugar else         is "else";
sugar void         is "void";
sugar asm          is "asm";
sugar return       is "return";
sugar null         is "NULL";
sugar nil          is "nil";
sugar template     is "template";
sugar using        is "using";
sugar inf          is "\<";
sugar infeq        is "\<=";
sugar sup          is "\>";
sugar supeq        is "\>=";
sugar eq           is "==";
sugar neq          is "\!=";
sugar plus         is "\+";
sugar minus        is "\-";
sugar or           is "\|\|";
sugar and          is "\&\&";
sugar mult         is "\*";
sugar div          is "\/";
sugar mod          is "\%";
sugar not          is "\!";

-- TODO:MOC:
--sugar colon      is "\:";
--sugar osbra      is "\[";
--sugar csbra      is "\]";
--sugar id         is "id";
--sugar class      is "@class";
--sugar end        is "@end";
--sugar self       is "self";
--sugar bool       is "BOOL";
--sugar super      is "super";
--sugar yes        is "YES";
--sugar no         is "NO";

term integer       is "[0-9]+";
term character     is "\'[^\']\'";
term string        is "\"[^\"]*\"";
term ident         is "[a-z][_0-9A-Za-z]*";
term typeident     is "[A-Z][_0-9A-Za-z]*";

-- TODO:MOC:
--term stringo     is "@\"[^\"]*\"";         -- string MOC

-- for inline assembly
compil ASM;

--production rules
PROGRAM -> #init ENTITIES #gen;
global
   IMachine machine;
#init {
    machine = PROGRAM^source.getMachine();
    if(machine == null) {
        error(NO_MACH, PROGRAM^source.getMachName());
    }
    else {
        ENTITIES^machine = machine;
        TDS tds = new TDS();
        tds.insertType("Int", machine.getIntType());
        tds.insertType("Char", machine.getCharType());

        ENTITIES^tds = tds;
    }
}
-- write the code in a file
#gen { machine.writeCode(PROGRAM^source.getFileName(),"; no code\n"); }

ENTITIES -> ;

ENTITIES -> asm #tds ASM ENTITIES #gen;
#tds {
    -- Replace null with the current symbols table so that the ASM
    -- code can access MC or MOC variables
    ASM^tds_asm = null;
}
#gen {
    -- ASM^code_asm contains the inline ASM
}

ENTITIES -> FUNCTION ENTITIES;

--fonctions
FUNCTION -> TYPE ident #ctds opar FUNC_PARAMETERS #utds cpar BLOC #returns;
global
    TDS bloc_tds;
    LTYPES types;
#ctds {
    bloc_tds = new TDS(FUNCTION^tds);
    types = new LTYPES();
    FUNC_PARAMETERS^types = types;
    FUNC_PARAMETERS^tds = bloc_tds;
    BLOC^tds = bloc_tds;
}
#utds {
    if(FUNCTION^tds.localSearch(ident^txt) != null) {
        error(FUN_exists, ident^txt);
    }
    else {
        bloc_tds.setCurrentFunction(
            ident^txt, new DFUNCTIONTYPE(TYPE^type, types)
        );
    }
}
#returns {
    if(BLOC^returns != 2 && !instanceof(TYPE^type, VOID_t)) {
        error(FUN_missingReturn);
    }
}

-- parametres de fonctions
FUNC_PARAMETERS -> ;
FUNC_PARAMETERS -> FUNC_PARAMETER FUNC_PARAMETERSX;

FUNC_PARAMETERSX -> ;
FUNC_PARAMETERSX -> comma FUNC_PARAMETER FUNC_PARAMETERSX;

FUNC_PARAMETER -> TYPE ident #tds;
#tds {
    INFO info = FUNC_PARAMETER^tds.localSearch(ident^txt);

    if(info != null) {
        error(VAR_exists, ident^txt);
    }
    else {
        match(TYPE^type) {
            case VOID_t {
                error(TYPE_void);
            }
            default {
                FUNC_PARAMETER^types.add(TYPE^type);
                FUNC_PARAMETER^tds.insertVar(ident^txt, TYPE^type);
            }
        }
    }
}

-- base types and pointers
TYPE -> STYPE #get REFS #gen;
#get { REFS^htype = STYPE^type; }
#gen { TYPE^type = REFS^type; }

REFS -> #gen; #gen { REFS^type = REFS^htype; }

REFS -> mult REFS #gen; #gen { REFS^type = REFS^machine.getPtrType(REFS1^type); }

STYPE -> void #gen; #gen { STYPE^type = new VOID_t(); }
STYPE -> typeident #gen;
#gen {
    INFO info = STYPE^tds.globalSearch(typeident^txt);
    if(info == null) {
        error(TYPE_unknown, typeident^txt);
    }
    else {
        match(info) {
            case INFOTYPE {
                STYPE^type = info.getType();
            }
            default {
                error(VAR_notAVariable, typeident^txt);
            }
        }
    }
}

-- method body and instructions blocks
BLOC -> #tds occbra INSTS ccbra #message;
global
    TDS tds;
#tds {
    tds = new TDS(BLOC^tds);
    INSTS^tds = tds;
}
#message {
    BLOC^returns = INSTS^returns;
    if(BLOC^machine.verbose(5)) {
        write("Symbols: " + tds.toString()+"\n");
    }
}

-- instructions
INSTS -> #returns; #returns { INSTS^returns = 0; }
INSTS -> INST INSTS #returns;
#returns {
    if(INST^returns == 2 || INSTS1^returns == 2) {
        INSTS^returns = 2;
    }
    else {
        INSTS^returns = 1;
    }

    if(INST^returns == 2
    && INSTS1^returns != 0
    && INSTS^machine.hasWarning("unreachable")) {
        warning(WARN_unreachable);
    }
}

-- typedef declaration
INST -> using typeident affect TYPE #tds semicolumn;
#tds {
    INST^returns = 1;

    if(INST^tds.localSearch(typeident^txt) != null) {
        error(TYPE_exists, typeident^txt);
    }
    elseif(instanceof(TYPE^type, VOID_t)) {
        error(TYPE_void);
    }
    else {
        INST^tds.insertType(typeident^txt, TYPE^type);
    }
}

-- local variable declaration with or without initialisation
INST -> TYPE ident EX semicolumn #tds;
#tds {
    INST^returns = 1;

    INFO info = INST^tds.localSearch(ident^txt);
    if(info != null) {
        error(VAR_exists, ident^txt);
    }
    else {
        if(EX^type != null && !TYPE^type.constructsFrom(EX^type)) {
            error(TYPE_unexpected, TYPE^type, EX^type);
        }

        if(instanceof(TYPE^type, VOID_t)) {
            error(TYPE_void);
        }

        -- we add the variable in the symbol table even when there is an
        -- error in order to avoid a lot of "unknown variable"
        -- TODO:emplacement
        INST^tds.insertVar(ident^txt, TYPE^type);
    }
}

-- expression instruction (affectation and procedure call)
INST -> E semicolumn #returns; #returns { INST^returns = 1; }

-- instruction block
INST -> BLOC #returns; #returns { INST^returns = BLOC^returns; }

-- conditional
INST -> if opar E cpar BLOC ELSE #returns;
#returns {
    if(!E^type.testable()) {
        error(TYPE_unexpected, "int", E^type);
    }
    elseif(BLOC^returns == 2 && ELSE^returns != 1) {
        INST^returns = 2;
    }
    else {
        INST^returns = 1;
    }
}

ELSE -> else BLOC #returns; #returns { ELSE^returns = BLOC^returns; }
ELSE -> #returns; #returns { ELSE^returns = 0 ; }

-- function return
INST -> return E semicolumn #type;
#type {
    INST^returns = 2;
    if(!INST^tds.canReturn(E^type)) {
        error(FUN_returnType, E^type);
    }
}

-- inline asm
INST -> asm  #tds ASM #gen;
#tds {
    -- to replace by the current symbols table so that inline
    -- assembly can access variables
    ASM^tds_asm = null;
}
#gen {
    INST^returns = 2; -- TODO: may want to actually check it
    -- ASM^code_asm contains the inline assembly in which variable
    -- names have been replaced by their addresses
}

-- expressions
-----------------------------------------------------------------------
-- E = expression (including affectation)
-- A = expression figuring in an affectation
-- R = expression figuring in a relational expression
-- T = expression figuring in an additive expression (TERME)
-- F = expression figuring in a multiplicative expression (FACTOR)
-----------------------------------------------------------------------
-- affectation
E -> A EX #type;
#type {
    if(EX^type == null) {
        E^type = A^type;
    }
    elseif(A^type.constructsFrom(EX^type)) {
        E^type = A^type;
    }
    else {
        error(TYPE_unexpected, A^type, EX^type);
    }
}

EX -> #type; #type { EX^type = null; }

EX -> affect A #type; #type { EX^type = A^type; }

-- relations
OPREL -> inf   #get; #get { OPREL^sym = "<"; }
OPREL -> sup   #get; #get { OPREL^sym = ">"; }
OPREL -> infeq #get; #get { OPREL^sym = "<="; }
OPREL -> supeq #get; #get { OPREL^sym = ">="; }
OPREL -> eq    #get; #get { OPREL^sym = "=="; }
OPREL -> neq   #get; #get { OPREL^sym = "!="; }

A -> R #htype AX #type;
#htype { AX^htype = R^type; }
#type { A^type = AX^type; }

AX -> #type; #type { AX^type = AX^htype; }

AX -> OPREL R #type;
#type {
    if(AX^htype.comparableWith(R^type, OPREL^sym)) {
            AX^type = AX^machine.getIntType();
    }
    else {
        error(TYPE_notComparable, AX^htype, R^type);
    }
}

-- additions
OPADD -> plus;
OPADD -> minus;
OPADD -> or;

R -> T #htype RX #type;
#htype { RX^htype = T^type; }
#type { R^type = RX^type; }

RX -> #type;
#type { RX^type = RX^htype; }

RX -> OPADD T RX #type;
#type {
    -- TODO:MOC: booleans with or
    match(RX^htype) {
        case INTEGER_t {
            match(T^type) {
                case INTEGER_t {
                    RX^type = T^type;
                }
                default {
                    error(TYPE_unexpected, "int", T^type);
                }
            }
        }
        default {
            error(TYPE_unexpected, "int", RX^htype);
        }
    }
}

-- multiplication
OPMUL -> mult;
OPMUL -> div;
OPMUL -> mod;
OPMUL -> and;

T -> F #htype TX #type;
#htype { TX^htype = F^type; }
#type { T^type = TX^type; }

TX -> #type; #type { TX^type = TX^htype; }

TX -> OPMUL F TX #type;
#type {
    -- TODO:MOC: booleans with and
    match(TX^htype) {
        case INTEGER_t {
            match(F^type) {
                case INTEGER_t {
                    TX^type = F^type;
                }
                default {
                    error(TYPE_unexpected, "int", F^type);
                }
            }
        }
        default {
            error(TYPE_unexpected, "int", TX^htype);
        }
    }
}

-- base expressions
F -> integer #type; #type { F^type = F^machine.getIntType(); }

F -> string #type;
#type {
    -- TODO:array
    F^type = F^machine.getPtrType(F^machine.getCharType());
}

F -> character #type; #type { F^type = F^machine.getCharType(); }

F -> null #type; #type { F^type = new NULL_t(); }

-- unary expression
OPUN -> plus;
OPUN -> minus;
OPUN -> not;
F -> OPUN F #type;
#type {
    -- TODO:MOC: booleans with not
    match(F1^type) {
        case INTEGER_t {
            F^type = F1^type;
        }
        default {
            error(TYPE_unexpected, "int", F1^type);
        }
    }
}

-- parenthesised expression
F -> opar E cpar #type; #type { F^type = E^type; }

F -> opar TYPE cpar F #type;
#type {
    if(F1^type != null && !TYPE^type.constructsFrom(F1^type)) {
        error(TYPE_unexpected, TYPE^type, F1^type);
    }
    F^type = TYPE^type;
}

-- subprogram call
F -> ident opar #types ARGS cpar #type;
global
    LTYPES types;
#types {
    types = new LTYPES();
    ARGS^types = types;
}
#type {
    INFO info  = F^tds.globalSearch(ident^txt);
    DFUNCTIONTYPE fun;
    if(info == null) {
        error(FUN_unknown, ident^txt);
    }
    else {
        match(info) {
            case INFOFUN {
                fun = info.getType();
                F^type = fun.getReturnType();
                if(!fun.callableWith(types)) {
                    error(FUN_unexpected, fun.getParameterTypes(), types);
                }
            }
            default {
                error(FUN_notCallable, ident^txt);
            }
        }
    }
}

F -> ident #type;
#type {
    INFO info = F^tds.globalSearch(ident^txt);
    if(info == null) {
        error(VAR_unknown, ident^txt);
    }
    else {
        match(info) {
            case INFOVAR {
                F^type = info.getType();
            }
            default {
                error(VAR_notAVariable, ident^txt);
            }
        }
    }
}

-- acces zone pointee
F -> mult F #type;
#type {
    match(F1^type) {
        case POINTER {
            F^type = F1^type.getPointee();
        }
        default {
            error(TYPE_notAPtr, F1^type);
        }
    }
}

-- subprogram call arguments
ARGS -> ;
ARGS -> E #type ARGSX; #type { ARGS^types.add(E^type); }

ARGSX -> ;
ARGSX -> comma E #type ARGSX; #type { ARGSX^types.add(E^type); }

-- TODO:MOC:
--ENTITIES -> IMPLEMENTATION ENTITIES;
---- class definition
--IMPLEMENTATION -> class classident SUPER occbra ATTRIBUTS ccbra METHODES end;
---- superclass
--SUPER -> ;
--SUPER -> colon classident;
----attributes
--ATTRIBUTS -> ;
--ATTRIBUTS -> TYPE ident semicolumn ATTRIBUTS;
-- -- methods
--METHODES -> ;
--METHODES -> METHODE  METHODES;
--METHODE -> QUAL PTYPE   MFUNC_PARAMETERS BLOC;
-- --method or attribute qualifier: + = class, - = instance
--QUAL -> plus;
--QUAL -> minus;
-- --type class
--STYPE-> classident;
-- -- type BOOL
--STYPE-> bool;
-- -- type "any"
--TYPE -> id;
---- method return type between parens
--PTYPE-> opar TYPE cpar;
---- method parameters
--MFUNC_PARAMETERS -> ;
--MFUNC_PARAMETERS -> MFUNC_PARAMETER MFUNC_PARAMETERS;
-- -- selector without parameters
--MFUNC_PARAMETER -> ident;
-- -- selector  + parameter type + parameter name
--MFUNC_PARAMETER -> ident colon  PTYPE ident;
---- object nil
--F -> nil;
---- 'YES' constant
--F -> yes;
---- 'NO' constant
--F -> no;
-- -- string MOC (starts with @)
--F -> stringo;
--  --self = Java "this"
--F -> self;
--F -> super;
-- -- method call
--F -> osbra F MARGS csbra;
---- for class method call
--F -> osbra classident MARGS csbra;
---- method call arguments
--MARGS -> ;
--MARGS -> MARG MARGS;
-- -- selector + arg
--MARG -> ident colon  E;
-- -- selector without arg
--MARG -> ident;
---- --end of MOC extension
