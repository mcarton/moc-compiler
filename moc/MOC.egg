-----------------------------------------------------
-- MC and MOC grammars                             --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k = 2;

-- the source file
inh source : MOCSourceFile for PROGRAM;
-- the target machine for code generation
inh machine : IMachine for
    ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
    FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX,
    E, EX, A, AX, R, RX, T, TX, F,
    REFS, STYPE, TYPE, SIZEOFEXPR
-- TODO:MOC:
--       ,IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS,
--       MFUNC_PARAMETER, MFUNC_PARAMETERS,MARG, MARGS
;

-- the current symbols table
inh symbolTable : SymbolTable for
    ENTITIES, BLOC, ELSE, INST, INSTS, ARGS, ARGSX,
    FUNCTION, FUNC_PARAMETER, FUNC_PARAMETERS, FUNC_PARAMETERSX,
    TYPE, STYPE, REFS, SIZEOFEXPR,
    F, TX, T, RX, R, AX, A, EX, E
;

-- 0 => empty statement, 1 => non-empty but does not return, 2 => returns
syn returns : int for
    INST, INSTS, BLOC, ELSE;

-- types:
syn type : Type for
    TYPE, STYPE, REFS, SIZEOFEXPR,
    F, TX, T, RX, R, AX, A, EX, E
;
inh htype : Type for
    REFS,
    TX, RX, AX
;
inh parameters : ArrayList<Location> for
    FUNC_PARAMETERS, FUNC_PARAMETERSX, FUNC_PARAMETER
;
inh types : TypeList for
    FUNC_PARAMETERS, FUNC_PARAMETERSX, FUNC_PARAMETER,
    ARGS, ARGSX
;

syn sym : String for OPREL, OPADD, OPMUL, OPUN;

syn code : String for
    ENTITIES, BLOC, ELSE, INST, INSTS,
    FUNCTION
;
syn expr : Expr for
    F, TX, T, RX, R, AX, A, EX, E
;
inh hexpr : Expr for TX, RX, AX;
inh exprs : ArrayList<Expr> for ARGS, ARGSX;

--terminals
space separator    is "[\r\n\t ]+";
comment comm       is "\/\/[^\n]*\n";
comment ml_comm    is "\/\*([^\*]|(\*+[^\*\/]))*\*+\/";
sugar opar         is "\(";
sugar cpar         is "\)";
sugar occbra       is "\{";
sugar ccbra        is "\}";
sugar comma        is ",";
sugar semicolon    is "\;";
sugar affect       is "=";
sugar if           is "if";
sugar else         is "else";
sugar void         is "void";
sugar new          is "new";
sugar delete       is "delete";
sugar sizeof       is "sizeof";
sugar asm          is "asm";
sugar return       is "return";
sugar null         is "NULL";
sugar nil          is "nil";
sugar template     is "template";
sugar using        is "using";
sugar inf          is "\<";
sugar infeq        is "\<=";
sugar sup          is "\>";
sugar supeq        is "\>=";
sugar eq           is "==";
sugar neq          is "\!=";
sugar plus         is "\+";
sugar minus        is "\-";
sugar or           is "\|\|";
sugar and          is "\&\&";
sugar mult         is "\*";
sugar div          is "\/";
sugar mod          is "\%";
sugar not          is "\!";

-- TODO:MOC:
--sugar colon      is "\:";
sugar osbra        is "\[";
sugar csbra        is "\]";
--sugar id         is "id";
--sugar class      is "@class";
--sugar end        is "@end";
--sugar self       is "self";
--sugar bool       is "BOOL";
--sugar super      is "super";
--sugar yes        is "YES";
--sugar no         is "NO";

term integer       is "[0-9]+";
term character     is "\'([^\'\\]|\\\\|\\n|\\t|\\\"|\\\')\'";
term string        is "\"([^\"\\]|\\\\|\\n|\\t|\\\"|\\\')*\"";
term ident         is "[a-z][_0-9A-Za-z]*";
term typeident     is "[A-Z][_0-9A-Za-z]*";

-- TODO:MOC:
--term stringo     is "@\"[^\"]*\"";

--production rules
PROGRAM -> #init ENTITIES #gen;
global
   IMachine machine;
#init {
    machine = PROGRAM^source.getMachine();
    ENTITIES^machine = machine;

    SymbolTable symbolTable = new SymbolTable();
    ENTITIES^symbolTable = symbolTable;
    symbolTable.insertType("Int", new IntegerType());
    symbolTable.insertType("Char", new CharacterType());
    symbolTable.insertType("Null", new NullType());
}
#gen {
    machine.writeCode(PROGRAM^source.getFileName(), ENTITIES^code);
}

ENTITIES -> #gen;
#gen {
    ENTITIES^code = "";
}

ENTITIES -> FUNCTION ENTITIES #gen;
#gen {
    ENTITIES^code = FUNCTION^code + ENTITIES1^code;
}

-- functions
FUNCTION -> TYPE ident #csymbols opar FUNC_PARAMETERS #usymbols cpar BLOC #gen;
global
    SymbolTable blocTds;
    TypeList types;
    ArrayList<Location> parameters;
    FunctionType fun;
#csymbols {
    FUNCTION^machine.beginFunction();

    blocTds = new SymbolTable(FUNCTION^symbolTable);
    FUNC_PARAMETERS^symbolTable = blocTds;
    BLOC^symbolTable = blocTds;

    types = new TypeList();
    FUNC_PARAMETERS^types = types;

    parameters = new ArrayList<Location>();
    FUNC_PARAMETERS^parameters = parameters;
}
#usymbols {
    if (FUNCTION^symbolTable.localSearch(ident^txt) != null) {
        error(FUN_exists, ident^txt);
    }
    else {
        fun = new FunctionType(TYPE^type, types);
        blocTds.setCurrentFunction(ident^txt, fun);
    }
}
#gen {
    if (BLOC^returns != 2 && !instanceof(TYPE^type, VoidType)) {
        error(FUN_missingReturn);
    }
    elseif (fun != null) {
        FUNCTION^code = FUNCTION^machine.genFunction(
            fun, parameters, ident^txt, BLOC^code
        );
    }

    FUNCTION^machine.endFunction();
}

-- function parameters
FUNC_PARAMETERS -> ;
FUNC_PARAMETERS -> FUNC_PARAMETER FUNC_PARAMETERSX;

FUNC_PARAMETERSX -> ;
FUNC_PARAMETERSX -> comma FUNC_PARAMETER FUNC_PARAMETERSX;

FUNC_PARAMETER -> TYPE ident #symbolTable;
#symbolTable {
    if (FUNC_PARAMETER^symbolTable.localSearch(ident^txt) != null) {
        error(VAR_exists, ident^txt);
    }
    elseif (instanceof(TYPE^type, VoidType)) {
        error(TYPE_void);
    }
    else {
        if (FUNC_PARAMETER^machine.hasWarning("shadow")
        &&  FUNC_PARAMETER^symbolTable.globalSearch(ident^txt) != null) {
            warning(WARN_shadow, ident^txt);
        }

        FUNC_PARAMETER^types.add(TYPE^type);
        Location loc
            = FUNC_PARAMETER^machine.getLocationFor(ident^txt, TYPE^type);
        FUNC_PARAMETER^symbolTable.insertVar(ident^txt, TYPE^type, loc);
        FUNC_PARAMETER^parameters.add(loc);
    }
}

-- base types and pointers
TYPE -> void #gen; #gen { TYPE^type = new VoidType(); }

TYPE -> STYPE #get REFS #gen;
#get { REFS^htype = STYPE^type; }
#gen { TYPE^type = REFS^type; }

REFS -> #gen; #gen { REFS^type = REFS^htype; }
REFS -> mult REFS #gen;
#gen {
    REFS^type = new Pointer(REFS1^type);
}

REFS -> osbra integer csbra REFS #gen;
#gen {
    int nbElements = new Integer(integer^txt);
    REFS^type = new Array(REFS1^type, nbElements);
}

STYPE -> typeident #gen;
#gen {
    Info info = STYPE^symbolTable.globalSearch(typeident^txt);
    if (info == null) {
        error(TYPE_unknown, typeident^txt);
    }
    else {
        match (info) {
            case InfoType {
                STYPE^type = info.getType();
            }
            default {
                error(VAR_notAVariable, typeident^txt);
            }
        }
    }
}

-- method body and instructions blocs
BLOC -> #symbolTable occbra INSTS ccbra #message #gen;
global
    SymbolTable symbolTable;
#symbolTable {
    BLOC^machine.beginBloc();

    symbolTable = new SymbolTable(BLOC^symbolTable);
    INSTS^symbolTable = symbolTable;
}
#message {
    BLOC^returns = INSTS^returns;
    if (BLOC^machine.verbosity() >= 5) {
        write("Symbols: " + symbolTable.toString()+"\n");
    }
}
#gen {
    BLOC^code = INSTS^code;
    BLOC^machine.endBloc();
}

-- instructions
INSTS -> #returns #gen;
#returns {
    INSTS^returns = 0;
}
#gen {
    INSTS^code = "";
}

INSTS -> INST INSTS #returns #gen;
#returns {
    if (INST^returns == 2 || INSTS1^returns == 2) {
        INSTS^returns = 2;
    }
    else {
        INSTS^returns = 1;
    }

    if (INST^returns == 2
    && INSTS1^returns != 0
    && INSTS^machine.hasWarning("unreachable")) {
        warning(WARN_unreachable);
    }
}
#gen {
    INSTS^code = INST^code + INSTS1^code;
}

-- typedef declaration
INST -> using typeident affect TYPE semicolon #symbolTable #gen;
#symbolTable {
    INST^returns = 1;

    if (INST^symbolTable.localSearch(typeident^txt) != null) {
        error(TYPE_exists, typeident^txt);
    }
    elseif (instanceof(TYPE^type, VoidType)) {
        error(TYPE_void);
    }
    else {
        if (INST^machine.hasWarning("shadow")
        && INST^symbolTable.globalSearch(typeident^txt) != null) {
            warning(WARN_shadow, typeident^txt);
        }

        INST^symbolTable.insertType(typeident^txt, TYPE^type);
    }
}
#gen {
    INST^code = ""; -- TODO:code
}

-- local variable declaration with or without initialisation
INST -> TYPE ident EX semicolon #symbolTable #gen;
global
    Location loc;
#symbolTable {
    INST^returns = 1;

    Info info = INST^symbolTable.localSearch(ident^txt);
    if (info != null) {
        error(VAR_exists, ident^txt);
    }
    else {
        if (EX^type != null && !TYPE^type.constructsFrom(EX^type)) {
            error(TYPE_unexpected, TYPE^type, EX^type);
        }

        if (instanceof(TYPE^type, VoidType)) {
            error(TYPE_void);
        }

        if (INST^machine.hasWarning("shadow")
        && INST^symbolTable.globalSearch(ident^txt) != null) {
            warning(WARN_shadow, ident^txt);
        }

        -- we add the variable in the symbol table even when there is an
        -- error in order to avoid a lot of "unknown variable"
        loc = INST^machine.getLocationFor(ident^txt, TYPE^type);
        INST^symbolTable.insertVar(ident^txt, TYPE^type, loc);
    }
}
#gen {
    if (EX^expr == null) {
        INST^code = INST^machine.genVarDecl(TYPE^type, loc);
    }
    else {
        INST^code = INST^machine.genVarDecl(TYPE^type, loc, EX^expr);
    }
}

-- expression instruction (affectation and procedure call)
INST -> E semicolon #returns #gen;
#returns {
    INST^returns = 1;
}
#gen {
    if (E^expr != null) {
        INST^code = E^expr.getCode(); -- TODO:code
    }
}

-- instruction block
INST -> BLOC #returns #gen;
#returns {
    INST^returns = BLOC^returns;
}
#gen {
    INST^code = BLOC^code; -- TODO:code

}

-- conditional
INST -> if opar E cpar BLOC ELSE #returns #gen;
#returns {
    if (!E^type.testable()) {
        error(TYPE_unexpected, "int", E^type);
    }
    elseif (BLOC^returns == 2 && ELSE^returns != 1) {
        INST^returns = 2;
    }
    else {
        INST^returns = 1;
    }
}
#gen {
    INST^code = ""; -- TODO:code

}

ELSE -> else BLOC #returns #gen;
#returns {
    ELSE^returns = BLOC^returns;
}
#gen {
    ELSE^code = BLOC^code; -- TODO:code
}

ELSE -> #returns #gen;
#returns {
    ELSE^returns = 0;
}
#gen {
    ELSE^code = ""; -- TODO:code
}

-- function return
INST -> return E semicolon #type #gen;
#type {
    INST^returns = 2;
    Type type = INST^symbolTable.getCurrentFunction().getReturnType();
    if (!type.constructsFrom(E^type)) {
        error(TYPE_unexpected, type, E^type);
    }
}
#gen {
    INST^code
        = INST^machine.genReturn(INST^symbolTable.getCurrentFunction(), E^expr);
}

-- expressions
-----------------------------------------------------------------------
-- E = expression (including affectation)
-- A = expression figuring in an affectation
-- R = expression figuring in a relational expression
-- T = expression figuring in an additive expression (TERME)
-- F = expression figuring in a multiplicative expression (FACTOR)
-----------------------------------------------------------------------
-- affectation
E -> A EX #type;
#type {
    if (EX^type == null) {
        E^type = A^type;
    }
    elseif (A^type.constructsFrom(EX^type)) {
        E^type = A^type;
    }
    else {
        error(TYPE_unexpected, A^type, EX^type);
    }

    -- `EX -> ;` => EX^expr == null
    if (EX^expr == null) {
        E^expr = E^machine.genNonAff(A^type, A^expr);
    }
    else {
        -- TODO: A must be an lvalue
        E^expr = E^machine.genAff(A^type, A^expr.getLoc(), EX^expr);
    }
}

EX -> #init;
#init {
    EX^type = null;
    EX^expr = null;
}

EX -> affect A #init;
#init {
    EX^type = A^type;
    EX^expr = A^expr;
}

-- relations
OPREL -> inf   #get; #get { OPREL^sym = "<"; }
OPREL -> sup   #get; #get { OPREL^sym = ">"; }
OPREL -> infeq #get; #get { OPREL^sym = "<="; }
OPREL -> supeq #get; #get { OPREL^sym = ">="; }
OPREL -> eq    #get; #get { OPREL^sym = "=="; }
OPREL -> neq   #get; #get { OPREL^sym = "!="; }

A -> R #init AX #gen;
#init {
    AX^htype = R^type;
    AX^hexpr = R^expr;
}
#gen {
    A^type = AX^type;
    A^expr = AX^expr;
}

AX -> #type #gen;
#type {
    AX^type = AX^htype;
}
#gen {
    AX^expr = AX^hexpr;
}

AX -> OPREL R #type;
#type {
    if (AX^htype.comparableWith(R^type, OPREL^sym)) {
        AX^type = new IntegerType();
        -- TODO:code
        AX^expr = AX^hexpr;
    }
    else {
        error(TYPE_notComparable, AX^htype, R^type);
    }
}

-- additions
OPADD -> plus  #get; #get { OPADD^sym = "+"; }
OPADD -> minus #get; #get { OPADD^sym = "-"; }
OPADD -> or    #get; #get { OPADD^sym = "||"; }

R -> T #init RX #gen;
#init {
    RX^htype = T^type;
    RX^hexpr = T^expr;
}
#gen {
    R^type = RX^type;
    R^expr = RX^expr;
}

RX -> #type;
#type {
    RX^type = RX^htype;
    RX^expr = RX^hexpr;
}

RX -> OPADD T #gen RX #gen2;
#gen {
    TypedExpr typedExpr = RX^machine.genBinaryOp(
        OPADD^sym, RX^htype, RX^hexpr, T^type, T^expr
    );

    if (typedExpr != null) {
        RX1^hexpr = typedExpr.getExpr();
        RX1^htype = typedExpr.getType();
    }
    else {
        error(OP_type, RX^htype, T^type, OPADD^sym);
    }
}
#gen2 {
    RX^expr = RX1^expr;
    RX^type = RX1^type;
}

-- multiplication
OPMUL -> mult #gen; #gen { OPMUL^sym = "*"; }
OPMUL -> div  #gen; #gen { OPMUL^sym = "/"; }
OPMUL -> mod  #gen; #gen { OPMUL^sym = "%"; }
OPMUL -> and  #gen; #gen { OPMUL^sym = "&&"; }

T -> F #init TX #gen;
#init {
    TX^htype = F^type;
    TX^hexpr = F^expr;
}
#gen {
    T^type = TX^type;
    T^expr = TX^expr;
}

TX -> #type;
#type {
    TX^type = TX^htype;
    TX^expr = TX^hexpr;
}

TX -> OPMUL F #gen TX #gen2;
#gen {
    TypedExpr typedExpr = TX^machine.genBinaryOp(
        OPMUL^sym, TX^htype, TX^hexpr, F^type, F^expr
    );

    if (typedExpr != null) {
        TX1^hexpr = typedExpr.getExpr();
        TX1^htype = typedExpr.getType();
    }
    else {
        error(OP_type, TX^htype, F^type, OPMUL^sym);
    }
}
#gen2 {
    TX^expr = TX1^expr;
    TX^type = TX1^type;
}

TX -> osbra E csbra #type;
#type {
    match (TX^htype) {
        case Array {
            if (instanceof(E^type, IntegerType)) {
                TX^type = TX^htype.getPointee();

                -- TODO:code
                TX^expr = E^expr;
            }
            else {
                error(TYPE_unexpected, "int", E^type);
            }
        }
        default {
            error(TYPE_unexpected, "array", TX^htype);
        }
    }
}

-- base expressions
F -> integer #type;
#type {
    F^type = new IntegerType();
    F^expr = F^machine.genInt(integer^txt);
}

F -> string #type;
#type {
    int length = F^machine.stringSize(string^txt);

    F^type = new Array(new CharacterType(), length);
    F^expr = F^machine.genString(length, string^txt);
}

F -> character #type;
#type {
    F^type = new CharacterType();
    F^expr = F^machine.genCharacter(character^txt);
}

F -> null #type;
#type {
    F^type = new NullType();
    F^expr = F^machine.genNull();
}

-- unary expression
OPUN -> plus  #get; #get { OPUN^sym = "+"; }
OPUN -> minus #get; #get { OPUN^sym = "-"; }
OPUN -> not   #get; #get { OPUN^sym = "!"; }
F -> OPUN F #type;
#type {
    TypedExpr typedExpr = F^machine.genUnaryOp(OPUN^sym, F1^type, F1^expr);

    if (typedExpr != null) {
        F^expr = typedExpr.getExpr();
        F^type = typedExpr.getType();
    }
    else {
        error(OP_un_type, F1^type, OPUN^sym);
    }
}

-- new/delete expressions
F -> new opar TYPE cpar #type;
#type {
    if (instanceof(TYPE^type, VoidType)) {
        error(TYPE_void);
    }
    else {
        F^type = new Pointer(TYPE^type);
        F^expr = F^machine.genNew(TYPE^type);
    }
}

INST -> delete opar E cpar semicolon #gen;
#gen {
    if (instanceof(E^type, Pointer)) {
        INST^code = INST^machine.genDelete(E^type, E^expr);
    }
    else {
        error(TYPE_unexpected, "pointer", E^type);
    }
    INST^returns = 1;
}

F -> sizeof opar SIZEOFEXPR cpar #type;
#type {
    F^type = new IntegerType();
    if (SIZEOFEXPR^type != null) {
        F^expr = F^machine.genSizeOf(SIZEOFEXPR^type);
    }
}

SIZEOFEXPR -> TYPE #type; #type { SIZEOFEXPR^type = TYPE^type; }
SIZEOFEXPR -> E #type;    #type { SIZEOFEXPR^type = E^type; }

-- parenthesised expression
F -> opar E cpar #type;
#type {
    F^type = E^type;
    F^expr = F^machine.genParen(E^expr);
}

F -> opar TYPE cpar F #type;
#type {
    if (F1^type != null && !TYPE^type.constructsFrom(F1^type)) {
        error(TYPE_unexpected, TYPE^type, F1^type);
    }
    -- TODO: check here if cast is possible
    else {
        F^expr = F^machine.genCast(F1^type, TYPE^type, F1^expr);
    }
    F^type = TYPE^type;
}

-- subprogram call
F -> ident opar #types ARGS cpar #type;
global
    TypeList types;
    ArrayList<Expr> exprs;
#types {
    types = new TypeList();
    ARGS^types = types;
    exprs = new ArrayList<Expr>();
    ARGS^exprs = exprs;
}
#type {
    Info info  = F^symbolTable.globalSearch(ident^txt);
    if (info == null) {
        error(FUN_unknown, ident^txt);
    }
    else {
        match (info) {
            case InfoFun {
                FunctionType fun = info.getType();
                F^type = fun.getReturnType();

                if (fun.callableWith(types)) {
                    F^expr = F^machine.genCall(ident^txt, fun, exprs);
                }
                else {
                    error(FUN_unexpected, fun.getParameterTypes(), types);
                }
            }
            default {
                error(FUN_notCallable, ident^txt);
            }
        }
    }
}

F -> ident #type;
#type {
    Info info = F^symbolTable.globalSearch(ident^txt);
    if (info == null) {
        error(VAR_unknown, ident^txt);
    }
    else {
        match (info) {
            case InfoVar {
                F^type = info.getType();
                F^expr = F^machine.genIdent(info);
            }
            default {
                error(VAR_notAVariable, ident^txt);
            }
        }
    }
}

-- pointed-to memory access
F -> mult F #type;
#type {
    match (F1^type) {
        case Pointer {
            F^type = F1^type.getPointee();
            F^expr = F^machine.genDeref(F1^expr);
        }
        default {
            error(TYPE_notAPtr, F1^type);
        }
    }
}

-- subprogram call arguments
ARGS -> ;
ARGS -> E #type ARGSX;
#type {
    ARGS^types.add(E^type);
    ARGS^exprs.add(E^expr);
}

ARGSX -> ;
ARGSX -> comma E #type ARGSX;
#type {
    ARGSX^types.add(E^type);
    ARGSX^exprs.add(E^expr);
}

-- TODO:MOC:
--ENTITIES -> IMPLEMENTATION ENTITIES;
---- class definition
--IMPLEMENTATION -> class classident SUPER occbra ATTRIBUTS ccbra METHODES end;
---- superclass
--SUPER -> ;
--SUPER -> colon classident;
----attributes
--ATTRIBUTS -> ;
--ATTRIBUTS -> TYPE ident semicolon ATTRIBUTS;
-- -- methods
--METHODES -> ;
--METHODES -> METHODE  METHODES;
--METHODE -> QUAL PTYPE   MFUNC_PARAMETERS BLOC;
-- --method or attribute qualifier: + = class, - = instance
--QUAL -> plus;
--QUAL -> minus;
-- --type class
--STYPE-> classident;
-- -- type BOOL
--STYPE-> bool;
-- -- type "any"
--TYPE -> id;
---- method return type between parens
--PTYPE-> opar TYPE cpar;
---- method parameters
--MFUNC_PARAMETERS -> ;
--MFUNC_PARAMETERS -> MFUNC_PARAMETER MFUNC_PARAMETERS;
-- -- selector without parameters
--MFUNC_PARAMETER -> ident;
-- -- selector  + parameter type + parameter name
--MFUNC_PARAMETER -> ident colon  PTYPE ident;
---- object nil
--F -> nil;
---- 'YES' constant
--F -> yes;
---- 'NO' constant
--F -> no;
-- -- string MOC (starts with @)
--F -> stringo;
--  --self = Java "this"
--F -> self;
--F -> super;
-- -- method call
--F -> osbra F MARGS csbra;
---- for class method call
--F -> osbra classident MARGS csbra;
---- method call arguments
--MARGS -> ;
--MARGS -> MARG MARGS;
-- -- selector + arg
--MARG -> ident colon  E;
-- -- selector without arg
--MARG -> ident;
---- --end of MOC extension
