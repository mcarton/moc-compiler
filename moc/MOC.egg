-----------------------------------------------------
-- MC and MOC grammars                             --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k = 2;

-- the source file
inh source : MOCSourceFile for PROGRAM;
-- the target machine for code generation
inh machine : IMachine for
    ENTITIES, FUNCTION, INST, BLOC, INSTS, ELSE,
    FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS,ARGSX,
    E, EX, A, AX, R, RX, T, TX, F,
    REFS, STYPE, TYPE
-- TODO:MOC:
--       ,IMPLEMENTATION, METHODES, METHODE, ATTRIBUTS,
--       MFUNC_PARAMETER, MFUNC_PARAMETERS,MARG, MARGS
;

-- these attributes allow to get ASM inline
syn code_asm : STRING for ASM;

-- the current symbols table
inh tds_asm : TDS for ASM;
inh tds : TDS for
    ENTITIES, FUNCTION, BLOC, ELSE, INST, INSTS, ARGS, ARGSX,
    F, TX, T, RX, R, AX, A, EX, E

;

-- types:
syn type : DTYPE for
    TYPE, STYPE, REFS,
    F, TX, T, RX, R, AX, A, EX, E
;
inh htype : DTYPE for
    REFS,
    TX, RX, AX
;

--terminals
space separator    is "[\r\n\t ]+";
comment comm       is "\/\/[^\n]*\n";
comment ml_comm    is "\/\*([^\*]|(\*+[^\*\-]))*\*+\/";
sugar opar         is "\(";
sugar cpar         is "\)";
sugar occbra       is "\{";
sugar ccbra        is "\}";
sugar comma        is ",";
sugar semicolumn   is "\;";
sugar affect       is "=";
sugar if           is "if";
sugar else         is "else";
sugar void         is "void";
sugar asm          is "asm";
sugar int          is "int";
sugar char         is "char";
sugar return       is "return";
sugar null         is "NULL";
sugar nil          is "nil";
sugar inf          is "\<";
sugar infeq        is "\<=";
sugar sup          is "\>";
sugar supeq        is "\>=";
sugar eq           is "==";
sugar neq          is "\!=";
sugar plus         is "\+";
sugar minus        is "\-";
sugar or           is "\|\|";
sugar and          is "\&\&";
sugar mult         is "\*";
sugar div          is "\/";
sugar mod          is "\%";
sugar not          is "\!";

-- TODO:MOC:
--sugar colon      is "\:";
--sugar osbra      is "\[";
--sugar csbra      is "\]";
--sugar id         is "id";
--sugar class      is "@class";
--sugar end        is "@end";
--sugar self       is "self";
--sugar bool       is "BOOL";
--sugar super      is "super";
--sugar yes        is "YES";
--sugar no         is "NO";

term integer       is "[0-9]+";
term character     is "\'[^\']\'";
term string        is "\"[^\"]*\"";
term ident         is "[a-z][_0-9A-Za-z]*";

-- TODO:MOC:
--term classident  is "[A-Z][_0-9A-Za-z]*";  -- nom de class
--term stringo     is "@\"[^\"]*\"";         -- string MOC

-- for inline assembly
compil ASM;

--production rules
PROGRAM -> #init ENTITIES #gen;
global
   machine : IMachine;
#init {
    do
        machine := PROGRAM^source.getMachine();
        if machine = null then
            error(NO_MACH, PROGRAM^source.getMachName());
        else
            ENTITIES^machine := machine;
            ENTITIES^tds := new TDS();
        end
    end
}
-- write the code in a file
#gen {
    do
        machine.writeCode(PROGRAM^source.getFileName(),"; no code\n");
    end
}

ENTITIES -> ;

ENTITIES -> asm #tds ASM ENTITIES #gen;
#tds {
    do
        -- Replace null with the current symbols table so that the ASM
        -- code can access MC or MOC variables
        ASM^tds_asm := null;
    end
}
#gen {
    do
        -- ASM^code_asm contains the inline ASM
    end
}

ENTITIES -> FUNCTION ENTITIES;

--fonctions
FUNCTION -> TYPE ident  opar FUNC_PARAMETERS cpar BLOC;

-- paramÃ¨tres de fonctions
FUNC_PARAMETERS -> ;
FUNC_PARAMETERS -> FUNC_PARAMETER FUNC_PARAMETERSX;
FUNC_PARAMETERSX -> ;
FUNC_PARAMETERSX -> comma FUNC_PARAMETER FUNC_PARAMETERSX;
FUNC_PARAMETER -> TYPE ident;

-- base types and pointers
TYPE -> STYPE #get REFS #gen;
#get {
    do
        REFS^htype := STYPE^type;
    end
}
#gen {
    do
        TYPE^type := REFS^type;
    end
}

REFS -> #gen;
#gen {
    do
        REFS^type := REFS^htype;
    end
}

REFS -> mult REFS #gen;
#gen {
    do
        REFS^type := REFS^machine.getPtrType(REFS^htype);
    end
}

STYPE -> void #gen;
#gen {
    do
        STYPE^type := new VOID_t();
    end
}

STYPE -> int #gen;
#gen {
    do
        STYPE^type := STYPE^machine.getIntType();
    end
}

STYPE -> char #gen;
#gen {
    do
        STYPE^type := STYPE^machine.getCharType();
    end
}

-- method body and instructions blocks
BLOC -> #tds occbra INSTS ccbra #message;
global
    tds : TDS;
#tds {
    do
        tds := new TDS(BLOC^tds);
        INSTS^tds := tds;
    end
}
#message {
    do
        if BLOC^machine.verbose(5) then
            write "Symbols: " + tds.toString()+"\n";
        end
    end
}

-- instructions
INSTS -> ;
INSTS -> INST INSTS;

-- local variable declaration with or without initialisation
INST -> TYPE ident EX semicolumn #tds;
#tds {
    local
        info : INFO;
    do
        info := INST^tds.localSearch(ident^txt);

        if info != null then
            error(VAR_exists, ident^txt);
        else
            if(EX^type != null && !TYPE^type.constructsFrom(EX^type)) then
                error(TYPE_unexpected, TYPE^type, EX^type);
            end

            -- we add the variable in the symbol table even when there is an
            -- error in order to avoid a lot of "unknown variable"
            -- TODO:emplacement
            INST^tds.insert(ident^txt, new INFOVAR(TYPE^type, null));
        end
    end
}

-- expression instruction (affectation and procedure call)
INST -> E semicolumn;

-- instruction block
INST -> BLOC;

-- conditional
INST -> if opar E cpar BLOC ELSE;
ELSE -> else BLOC;
ELSE -> ;
-- function return
INST -> return E semicolumn;

-- inline asm
INST -> asm  #tds ASM #gen;
#tds {
    do
        -- to replace by the current symbols table so that inline
        -- assembly can access variables
        ASM^tds_asm := null;
    end
}
#gen {
    do
        -- ASM^code_asm contains the inline assembly in which variable
        -- names have been replaced by their addresses
    end
}

-- expressions
-----------------------------------------------------------------------
-- E = expression (including affectation)
-- A = expression figuring in an affectation
-- R = expression figuring in a relational expression
-- T = expression figuring in an additive expression (TERME)
-- F = expression figuring in a multiplicative expression (FACTOR)
-----------------------------------------------------------------------
-- affectation
E -> A EX #type;
#type {
    do
        if EX^type = null then
            E^type := A^type;
        elseif A^type.constructsFrom(EX^type) then
            E^type := A^type;
        else
            error(TYPE_unexpected, A^type, EX^type);
        end
    end
}

EX -> #type;
#type {
    do
        EX^type := null;
    end
}

EX -> affect A #type;
#type {
    do
        EX^type := A^type;
    end
}

-- relations
OPREL -> inf;
OPREL -> sup;
OPREL -> infeq;
OPREL -> supeq;
OPREL -> eq;
OPREL -> neq;

A -> R #htype AX #type;
#htype {
    do
        AX^htype := R^type;
    end
}
#type {
    do
        A^type := AX^type;
    end
}

AX -> #type;
#type {
    do
        AX^type := AX^htype;
    end
}

AX -> OPREL R #type;
#type {
    local
        err : boolean;
    do
        err := false;
        match AX^htype
        with INTEGER_t then
            match R^type
            with INTEGER_t then
            else
                err := true;
            end
        with CHARACTER_t then
            match R^type
            with CHARACTER_t then
            else
                err := true;
            end
        with POINTER then
            match R^type
            with POINTER then
            with NULL_t then
            else
                err := true;
            end
        with NULL_t then
            match R^type
            with POINTER then
            with NULL_t then
            else
                err := true;
            end
        else
            err := true;
        end

        if err then
            error(TYPE_notComparable, AX^htype, R^type);
        else
            AX^type := AX^machine.getIntType();
        end
    end
}

-- additions
OPADD -> plus;
OPADD -> minus;
OPADD -> or;

R -> T #htype RX #type;
#htype {
    do
        RX^htype := T^type;
    end
}
#type {
    do
        R^type := RX^type;
    end
}

RX -> #type;
#type {
    do
        RX^type := RX^htype;
    end
}

RX -> OPADD T RX #type;
#type {
    do
        -- TODO:MOC: booleans with or
        match RX^htype
        with INTEGER_t then
            match T^type
            with INTEGER_t then
                RX^type := T^type;
            else
                error(TYPE_unexpected, "int", T^type);
            end
        else
            error(TYPE_unexpected, "int", RX^htype);
        end
    end
}

-- multiplication
OPMUL -> mult;
OPMUL -> div;
OPMUL -> mod;
OPMUL -> and;

T -> F #htype TX #type;
#htype {
    do
        TX^htype := F^type;
    end
}
#type {
    do
        T^type := TX^type;
    end
}

TX -> #type;
#type {
    do
        TX^type := TX^htype;
    end
}

TX -> OPMUL F TX #type;
#type {
    do
        -- TODO:MOC: booleans with and
        match TX^htype
        with INTEGER_t then
            match F^type
            with INTEGER_t then
                TX^type := F^type;
            else
                error(TYPE_unexpected, "int", F^type);
            end
        else
            error(TYPE_unexpected, "int", TX^htype);
        end
    end
}

-- base expressions
F -> integer #type;
#type {
    do
        F^type := F^machine.getIntType();
    end
}

F -> string #type;
#type {
    do
        -- TODO:array
        F^type := F^machine.getPtrType(F^machine.getCharType());
    end
}

F -> character #type;
#type {
    do
        F^type := F^machine.getCharType();
    end
}

F -> null #type;
#type {
    do
        F^type := new NULL_t();
    end
}

-- unary expression
OPUN -> plus;
OPUN -> minus;
OPUN -> not;
F -> OPUN F #type;
#type {
    do
        -- TODO:MOC: booleans with not
        match F1^type
        with INTEGER_t then
            F^type := F1^type;
        else
            error(TYPE_unexpected, "int", F1^type);
        end
    end
}

-- parenthesised expression
F -> opar E cpar #type;
#type {
    do
        F^type := E^type;
    end
}

F -> opar TYPE cpar F #type;
#type {
    do
        F^type := null; --TODO:type
    end
}

-- subprogram call
F -> ident opar ARGS cpar #type;
#type {
    do
        F^type := null; --TODO:type
    end
}

F -> ident #type;
#type {
    local
        info : INFO;
    do
        info := F^tds.globalSearch(ident^txt);
        if info = null then
            error(VAR_unknown, ident^txt);
        else
            match info
            with INFOVAR then
                F^type := info.getType();
            else
                error(VAR_notAVariable, ident^txt);
            end
        end
    end
}

-- acces zone pointee
F -> mult F #type;
#type {
    do
        match F1^type
        with POINTER then
            F^type := F1^type.getPointee();
        else
            error(TYPE_notAPtr, F1^type);
        end
    end
}

-- subprogram call arguments
ARGS -> ;
ARGS -> E ARGSX;
ARGSX -> ;
ARGSX -> comma  E ARGSX;

-- TODO:MOC:
--ENTITIES -> IMPLEMENTATION ENTITIES;
---- class definition
--IMPLEMENTATION -> class classident SUPER occbra ATTRIBUTS ccbra METHODES end;
---- superclass
--SUPER -> ;
--SUPER -> colon classident;
----attributes
--ATTRIBUTS -> ;
--ATTRIBUTS -> TYPE ident semicolumn ATTRIBUTS;
-- -- methods
--METHODES -> ;
--METHODES -> METHODE  METHODES;
--METHODE -> QUAL PTYPE   MFUNC_PARAMETERS BLOC;
-- --method or attribute qualifier: + = class, - = instance
--QUAL -> plus;
--QUAL -> minus;
-- --type class
--STYPE-> classident;
-- -- type BOOL
--STYPE-> bool;
-- -- type "any"
--TYPE -> id;
---- method return type between parens
--PTYPE-> opar TYPE cpar;
---- method parameters
--MFUNC_PARAMETERS -> ;
--MFUNC_PARAMETERS -> MFUNC_PARAMETER MFUNC_PARAMETERS;
-- -- selector without parameters
--MFUNC_PARAMETER -> ident;
-- -- selector  + parameter type + parameter name
--MFUNC_PARAMETER -> ident colon  PTYPE ident;
---- object nil
--F -> nil;
---- 'YES' constant
--F -> yes;
---- 'NO' constant
--F -> no;
-- -- string MOC (starts with @)
--F -> stringo;
--  --self = Java "this"
--F -> self;
--F -> super;
-- -- method call
--F -> osbra F MARGS csbra;
---- for class method call
--F -> osbra classident MARGS csbra;
---- method call arguments
--MARGS -> ;
--MARGS -> MARG MARGS;
-- -- selector + arg
--MARG -> ident colon  E;
-- -- selector without arg
--MARG -> ident;
---- --end of MOC extension
end
