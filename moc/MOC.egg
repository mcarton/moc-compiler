-----------------------------------------------------
-- MC and MOC grammars                             --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k = 2;

-- the source file
inh source : MOCSourceFile for PROGRAM;
-- the target machine for code generation
inh machine : IMachine for
    ENTITIES, FUNCTION, ASM, INST, BLOCK, INSTS, IF, ELSE,
    FUNC_PARAMETERS, FUNC_PARAMETER, FUNC_PARAMETERSX, ARGS, ARGSX,
    IMPLEMENTATION, METHODS, ATTRIBUTS,
    E, EX, A, AX, R, RX, T, TX, F,
    REFS, STYPE, TYPE
--  MFUNC_PARAMETER, MFUNC_PARAMETERS,MARG, MARGS
;

-- the current symbols table
inh symbolTable : SymbolTable for
    ENTITIES, BLOCK, IF, ELSE, INST, INSTS, ARGS, ARGSX,
    FUNCTION, FUNC_PARAMETER, FUNC_PARAMETERS, FUNC_PARAMETERSX,
    IMPLEMENTATION, METHODS, ATTRIBUTS, SUPER,
    TYPE, STYPE, REFS,
    F, TX, T, RX, R, AX, A, EX, E
;

-- 0 => empty statement, 1 => non-empty but does not return, 2 => returns
syn returns : int for
    INST, INSTS, BLOCK, IF, ELSE;

-- types:
syn superType : ClassType for SUPER;
syn type : Type for
    TYPE, STYPE, REFS,
    F, TX, T, RX, R, AX, A, EX, E
;
inh htype : Type for
    REFS,
    TX, RX, AX
;
inh parameters : ArrayList<Location> for
    FUNC_PARAMETERS, FUNC_PARAMETERSX, FUNC_PARAMETER
;
inh types : TypeList for
    FUNC_PARAMETERS, FUNC_PARAMETERSX, FUNC_PARAMETER,
    ARGS, ARGSX
;

syn sym : String for OPREL, OPADD, OPMUL, OPUN;

syn code : String for
    ENTITIES, BLOCK, IF, ELSE, INST, INSTS,
    FUNCTION, ASM, IMPLEMENTATION
;
syn expr : Expr for
    F, TX, T, RX, R, AX, A, EX, E
;
inh hexpr : Expr for TX, RX, AX;
inh exprs : ArrayList<Expr> for ARGS, ARGSX;

inh currIndex : ListIterator<Type> for ARGS, ARGSX;

-- ok is true iff there were no error
syn  ok : boolean for ARGS, ARGSX;
inh hok : boolean for ARGS, ARGSX;

--terminals
space separator    is "[\r\n\t ]+";
comment comm       is "\/\/[^\n]*\n";
comment ml_comm    is "\/\*([^\*]|(\*+[^\*\/]))*\*+\/";
sugar opar         is "\(";
sugar cpar         is "\)";
sugar occbra       is "\{";
sugar ccbra        is "\}";
sugar comma        is ",";
sugar semicolon    is "\;";
sugar affect       is "=";
sugar if           is "if";
sugar else         is "else";
sugar void         is "void";
sugar new          is "new";
sugar delete       is "delete";
sugar sizeof       is "sizeof";
sugar asm          is "asm";
sugar return       is "return";
sugar null         is "null";
sugar template     is "template";
sugar using        is "using";
sugar inf          is "\<";
sugar infeq        is "\<=";
sugar sup          is "\>";
sugar supeq        is "\>=";
sugar eq           is "==";
sugar neq          is "\!=";
sugar plus         is "\+";
sugar minus        is "\-";
sugar or           is "\|\|";
sugar and          is "\&\&";
sugar mult         is "\*";
sugar div          is "\/";
sugar mod          is "\%";
sugar not          is "\!";

sugar colon        is "\:";
sugar osbra        is "\[";
sugar csbra        is "\]";
sugar id           is "id";
sugar class        is "class";
sugar end_         is "end";
sugar self         is "self";
sugar super        is "super";
sugar yes          is "yes";
sugar no           is "no";

term integer       is "[0-9]+";
term character     is "\'([^\'\\]|\\\\|\\n|\\t|\\\"|\\\')\'";
term string        is "\"([^\"\\]|\\\\|\\n|\\t|\\\"|\\\')*\"";
term ident         is "[a-z][_0-9A-Za-z]*";
term typeident     is "[A-Z][_0-9A-Za-z]*";

-- TODO:MOC:
--term stringo     is "@\"[^\"]*\"";

--production rules
PROGRAM -> #init ENTITIES #gen;
global
   IMachine machine;
#init {
    machine = PROGRAM^source.getMachine();
    ENTITIES^machine = machine;

    SymbolTable symbolTable = new SymbolTable();
    ENTITIES^symbolTable = symbolTable;
    symbolTable.insertType("Bool", new BooleanType());
    symbolTable.insertType("Int", new IntegerType());
    symbolTable.insertType("Char", new CharacterType());
    symbolTable.insertType("Null", new NullType());
}
#gen {
    machine.writeCode(PROGRAM^source.getFileName(), ENTITIES^code);
}

ENTITIES -> #gen;
#gen {
    ENTITIES^code = "";
}

ENTITIES -> FUNCTION ENTITIES #gen;
#gen {
    ENTITIES^code = FUNCTION^code + ENTITIES1^code;
}

ENTITIES -> ASM ENTITIES #gen;
#gen {
    ENTITIES^code = ASM^code + ENTITIES1^code;
}

ASM -> asm opar string cpar semicolon #gen;
#gen {
    ASM^code = ASM^machine.genGlobalAsm(string^txt);
}

-- functions
FUNCTION -> TYPE ident #csymbols opar FUNC_PARAMETERS #usymbols cpar BLOCK #gen;
global
    SymbolTable blockTds;
    TypeList types;
    ArrayList<Location> parameters;
    FunctionType fun;
#csymbols {
    blockTds = new SymbolTable(FUNCTION^symbolTable);
    FUNC_PARAMETERS^symbolTable = blockTds;
    BLOCK^symbolTable = blockTds;

    types = new TypeList();
    FUNC_PARAMETERS^types = types;

    parameters = new ArrayList<Location>();
    FUNC_PARAMETERS^parameters = parameters;
}
#usymbols {
    if (FUNCTION^symbolTable.localSearch(ident^txt) != null) {
        error(FUN_exists, ident^txt);
    }
    else {
        fun = new FunctionType(TYPE^type, types);

        FUNCTION^machine.beginFunction(fun);

        blockTds.setCurrentFunction(ident^txt, fun);
    }
}
#gen {
    if (BLOCK^returns != 2 && !TYPE^type.isVoid()) {
        error(FUN_missingReturn);
    }
    elseif (fun != null) {
        FUNCTION^code = FUNCTION^machine.genFunction(
            fun, parameters, ident^txt, BLOCK^code
        );
    }

    FUNCTION^machine.endFunction();
}

-- function parameters
FUNC_PARAMETERS -> ;
FUNC_PARAMETERS -> FUNC_PARAMETER FUNC_PARAMETERSX;

FUNC_PARAMETERSX -> ;
FUNC_PARAMETERSX -> comma FUNC_PARAMETER FUNC_PARAMETERSX;

FUNC_PARAMETER -> TYPE ident #symbolTable;
#symbolTable {
    if (FUNC_PARAMETER^symbolTable.localSearch(ident^txt) != null) {
        error(VAR_exists, ident^txt);
    }
    elseif (TYPE^type.isVoid()) {
        error(TYPE_void);
    }
    else {
        if (FUNC_PARAMETER^machine.hasWarning("shadow")
        &&  FUNC_PARAMETER^symbolTable.globalSearch(ident^txt) != null) {
            warning(WARN_shadow, ident^txt);
        }

        FUNC_PARAMETER^types.add(TYPE^type);
        Location loc
            = FUNC_PARAMETER^machine.getLocationFor(ident^txt, TYPE^type);
        FUNC_PARAMETER^symbolTable.insertVar(ident^txt, TYPE^type, loc);
        FUNC_PARAMETER^parameters.add(loc);
    }
}

-- base types and pointers
TYPE -> void #gen; #gen { TYPE^type = new VoidType(); }

TYPE -> STYPE #get REFS #gen;
#get { REFS^htype = STYPE^type; }
#gen { TYPE^type = REFS^type; }

REFS -> #gen; #gen { REFS^type = REFS^htype; }
REFS -> mult REFS #gen;
#gen {
    REFS^type = new Pointer(REFS1^type);
}

REFS -> osbra integer csbra REFS #gen;
#gen {
    int nbElements = new Integer(integer^txt);
    REFS^type = new Array(REFS1^type, nbElements);
}

STYPE -> typeident #gen;
#gen {
    Info info = STYPE^symbolTable.globalSearch(typeident^txt);
    if (info == null) {
        error(TYPE_unknown, typeident^txt);
    }
    else {
        match (info) {
            case InfoType {
                STYPE^type = info.getType();
            }
            default {
                error(TYPE_notAType, typeident^txt);
            }
        }
    }
}

-- method body and instructions blocks
BLOCK -> #symbolTable occbra INSTS ccbra #message #gen;
global
    SymbolTable symbolTable;
#symbolTable {
    BLOCK^machine.beginBlock();

    symbolTable = new SymbolTable(BLOCK^symbolTable);
    INSTS^symbolTable = symbolTable;
}
#message {
    BLOCK^returns = INSTS^returns;
    if (BLOCK^machine.verbosity() >= 5) {
        write("Symbols: " + symbolTable.toString()+"\n");
    }
}
#gen {
    BLOCK^code = BLOCK^machine.genInsts(INSTS^code);
    BLOCK^machine.endBlock();
}

-- instructions
INSTS -> #returns #gen;
#returns {
    INSTS^returns = 0;
}
#gen {
    INSTS^code = "";
}

INSTS -> INST INSTS #returns #gen;
#returns {
    if (INST^returns == 2 || INSTS1^returns == 2) {
        INSTS^returns = 2;
    }
    else {
        INSTS^returns = 1;
    }

    if (INST^returns == 2
    && INSTS1^returns != 0
    && INSTS^machine.hasWarning("unreachable")) {
        warning(WARN_unreachable);
    }
}
#gen {
    INSTS^code = INST^code + INSTS1^code;
}

-- asm instruction
INST -> asm opar string cpar semicolon #gen;
#gen {
    INST^code = INST^machine.genAsm(string^txt);
    INST^returns = 2; -- todo: actually check it
}

-- typedef declaration
INST -> using typeident affect TYPE semicolon #symbolTable #gen;
#symbolTable {
    INST^returns = 1;

    if (INST^symbolTable.localSearch(typeident^txt) != null) {
        error(TYPE_exists, typeident^txt);
    }
    elseif (TYPE^type.isVoid()) { -- TODO:moc: id
        error(TYPE_void);
    }
    else {
        if (INST^machine.hasWarning("shadow")
        && INST^symbolTable.globalSearch(typeident^txt) != null) {
            warning(WARN_shadow, typeident^txt);
        }

        INST^symbolTable.insertType(typeident^txt, TYPE^type);
    }
}
#gen {
    INST^code = INST^machine.genUsing(typeident^txt, TYPE^type);
}

-- local variable declaration with or without initialisation
INST -> TYPE ident EX semicolon #symbolTable #gen;
global
    Location loc;
    boolean ok;
#symbolTable {
    INST^returns = 1;
    ok = true;

    Info info = INST^symbolTable.localSearch(ident^txt);
    if (info != null) {
        error(VAR_exists, ident^txt);
        ok = false;
    }
    else {
        if (EX^type != null && !TYPE^type.constructsFrom(EX^type)) {
            error(TYPE_unexpected, TYPE^type, EX^type);
            ok = false;
        }

        if (TYPE^type.isVoid()) {
            error(TYPE_void);
            ok = false;
        }
        elseif (TYPE^type.isClass()) {
            error(TYPE_class);
            ok = false;
        }

        if (INST^machine.hasWarning("shadow")
        && INST^symbolTable.globalSearch(ident^txt) != null) {
            warning(WARN_shadow, ident^txt);
        }

        -- we add the variable in the symbol table even when there is an
        -- error in order to avoid a lot of "unknown variable"
        loc = INST^machine.getLocationFor(ident^txt, TYPE^type);
        INST^symbolTable.insertVar(ident^txt, TYPE^type, loc);
    }
}
#gen {
    if (ok) {
        if (EX^expr == null) {
            INST^code = INST^machine.genVarDecl(TYPE^type, loc);
        }
        else {
            Expr tmp = INST^machine.genCast(EX^type, TYPE^type, EX^expr);
            INST^code = INST^machine.genVarDecl(TYPE^type, loc, tmp);
        }
    }
}

-- expression instruction (affectation and procedure call)
INST -> E semicolon #returns #gen;
#returns {
    INST^returns = 1;
}
#gen {
    if (E^expr != null) {
        INST^code = INST^machine.genInst(E^expr);
    }
}

-- instruction blockk
INST -> BLOCK #returns #gen;
#returns {
    INST^returns = BLOCK^returns;
}
#gen {
    INST^code = INST^machine.genBlock(BLOCK^code);

}

-- conditional
INST -> IF #gen;
#gen {
    INST^code = INST^machine.genIfInst(IF^code);
    INST^returns = IF^returns;
}

ELSE -> else IF #gen;
#gen {
    ELSE^code = ELSE^machine.genElseIf(IF^code);
    ELSE^returns = IF^returns;
}

ELSE -> else BLOCK #returns #gen;
#returns {
    ELSE^returns = BLOCK^returns;
}
#gen {
    ELSE^code = ELSE^machine.genElse(BLOCK^code);
}

ELSE -> #returns #gen;
#returns {
    ELSE^returns = 0;
}
#gen {
    ELSE^code = ELSE^machine.genElse();
}

IF -> if opar E cpar #cast BLOCK ELSE #returns #gen;
global
    Expr casted;
#returns {
    if (!E^type.testable()) {
        error(TYPE_unexpected, "Int, Bool or pointer", E^type);
    }
    elseif (BLOCK^returns == 2 && ELSE^returns != 1) {
        IF^returns = 2;
    }
    else {
        IF^returns = 1;
    }
}
#cast {
    casted = IF^machine.genCast(E^type, new IntegerType(), E^expr);
}
#gen {
    IF^code = IF^machine.genIf(casted, BLOCK^code, ELSE^code);
}

-- function return
INST -> return E semicolon #gen;
#gen {
    INST^returns = 2;
    Type type = INST^symbolTable.getCurrentFunction().getReturnType();
    if (E^type != null) {
        if (type.constructsFrom(E^type)) {
            FunctionType function = INST^symbolTable.getCurrentFunction();
            Expr tmp = INST^machine.genCast(E^type, function.getReturnType(), E^expr);
            INST^code = INST^machine.genReturn(function, tmp);
        }
        else {
            error(TYPE_unexpected, type, E^type);
        }
    }
}

-- expressions
-----------------------------------------------------------------------
-- E = expression (including affectation)
-- A = expression figuring in an affectation
-- R = expression figuring in a relational expression
-- T = expression figuring in an additive expression (TERME)
-- F = expression figuring in a multiplicative expression (FACTOR)
-----------------------------------------------------------------------
-- affectation
E -> A EX #type;
#type {
    if (EX^type == null) {
        E^type = A^type;
    }
    elseif (A^type.constructsFrom(EX^type)) {
        E^type = A^type;
    }
    else {
        error(TYPE_unexpected, A^type, EX^type);
    }

    -- `EX -> ;` => EX^expr == null
    if (EX^expr == null) {
        E^expr = E^machine.genNonAff(A^type, A^expr);
    }
    else {
        -- TODO: A must be an lvalue
        Expr tmp = E^machine.genCast(EX^type, A^type, EX^expr);
        E^expr = E^machine.genAff(A^type, A^expr, tmp);
    }
}

EX -> #init;
#init {
    EX^type = null;
    EX^expr = null;
}

EX -> affect A #init;
#init {
    EX^type = A^type;
    EX^expr = A^expr;
}

-- relations
OPREL -> inf   #get; #get { OPREL^sym = "<"; }
OPREL -> sup   #get; #get { OPREL^sym = ">"; }
OPREL -> infeq #get; #get { OPREL^sym = "<="; }
OPREL -> supeq #get; #get { OPREL^sym = ">="; }
OPREL -> eq    #get; #get { OPREL^sym = "=="; }
OPREL -> neq   #get; #get { OPREL^sym = "!="; }

A -> R #init AX #gen;
#init {
    AX^htype = R^type;
    AX^hexpr = R^expr;
}
#gen {
    A^type = AX^type;
    A^expr = AX^expr;
}

AX -> #gen;
#gen {
    AX^type = AX^htype;
    AX^expr = AX^hexpr;
}

AX -> OPREL R #type;
#type {
    if (AX^htype.isInt() && R^type.isInt()) {
        AX^expr = AX^machine.genIntBinaryOp(OPREL^sym, AX^hexpr, R^expr);
    }
    elseif (AX^htype.isChar() && R^type.isChar()) {
        AX^expr = AX^machine.genCharBinaryOp(OPREL^sym, AX^hexpr, R^expr);
    }
    elseif (OPREL^sym.equals("==") || OPREL^sym.equals("!=")) {
        if (AX^htype.isNull() && R^type.isNull()) {
            AX^expr = AX^machine.genInt("1");
        }
        elseif (AX^htype.isPointer() && (R^type.isNull() || R^type.isPointer())) {
            Expr tmp = AX^machine.genCast(R^type, AX^htype, R^expr);
            AX^expr = AX^machine.genPtrBinaryOp(OPREL^sym, AX^htype, AX^hexpr, tmp);
        }
        elseif (R^type.isPointer() && (AX^htype.isNull() || AX^htype.isPointer())) {
            Expr tmp = AX^machine.genCast(AX^htype, R^type, AX^hexpr);
            AX^expr = AX^machine.genPtrBinaryOp(OPREL^sym, R^type, tmp, R^expr);
        }
    }
    else {
        error(OP_type, AX^htype, R^type, OPREL^sym);
    }

    AX^type = new IntegerType();
}

-- additions
OPADD -> plus  #get; #get { OPADD^sym = "+"; }
OPADD -> minus #get; #get { OPADD^sym = "-"; }
OPADD -> or    #get; #get { OPADD^sym = "||"; }

R -> T #init RX #gen;
#init {
    RX^htype = T^type;
    RX^hexpr = T^expr;
}
#gen {
    R^type = RX^type;
    R^expr = RX^expr;
}

RX -> #type;
#type {
    RX^type = RX^htype;
    RX^expr = RX^hexpr;
}

RX -> OPADD T #gen RX #gen2;
#gen {
    -- TODO:moc: || with booleans
    if (RX^htype.isInt() && T^type.isInt()) {
        RX1^hexpr = RX^machine.genIntBinaryOp(OPADD^sym, RX^hexpr, T^expr);
        RX1^htype = RX^htype;
    }
    else {
        error(OP_type, RX^htype, T^type, OPADD^sym);
    }
}
#gen2 {
    RX^expr = RX1^expr;
    RX^type = RX1^type;
}

-- multiplication
OPMUL -> mult #gen; #gen { OPMUL^sym = "*"; }
OPMUL -> div  #gen; #gen { OPMUL^sym = "/"; }
OPMUL -> mod  #gen; #gen { OPMUL^sym = "%"; }
OPMUL -> and  #gen; #gen { OPMUL^sym = "&&"; }

T -> F #init TX #gen;
#init {
    TX^htype = F^type;
    TX^hexpr = F^expr;
}
#gen {
    T^type = TX^type;
    T^expr = TX^expr;
}

TX -> #type;
#type {
    TX^type = TX^htype;
    TX^expr = TX^hexpr;
}

TX -> OPMUL F #gen TX #gen2;
#gen {
    -- TODO:moc: && with booleans
    if (TX^htype.isInt() && F^type.isInt()) {
        TX1^hexpr = TX^machine.genIntBinaryOp(OPMUL^sym, TX^hexpr, F^expr);
        TX1^htype = TX^htype;
    }
    else {
        error(OP_type, TX^htype, F^type, OPMUL^sym);
    }
}
#gen2 {
    TX^expr = TX1^expr;
    TX^type = TX1^type;
}

TX -> osbra E csbra #type;
#type {
    if (E^type.isInt()) {
        match (TX^htype) {
            case Array {
                TX^type = TX^htype.getPointee();
                TX^expr = TX^machine.genArrSub(TX^htype, TX^hexpr, E^expr);
            }
            case Pointer {
                TX^type = TX^htype.getPointee();
                TX^expr = TX^machine.genPtrSub(TX^htype, TX^hexpr, E^expr);
            }
            default {
                error(TYPE_unexpected, "array or pointer", TX^htype);
            }
        }
    }
    else {
        error(TYPE_unexpected, "Int", E^type);
    }
}

-- base expressions
F -> integer #type;
#type {
    F^type = new IntegerType();
    F^expr = F^machine.genInt(integer^txt);
}

F -> string #type;
#type {
    int length = F^machine.stringSize(string^txt);

    F^type = new Array(new CharacterType(), length);
    F^expr = F^machine.genString(length, string^txt);
}

F -> character #type;
#type {
    F^type = new CharacterType();
    F^expr = F^machine.genCharacter(character^txt);
}

F -> null #type;
#type {
    F^type = new NullType();
    F^expr = F^machine.genNull();
}

-- unary expression
OPUN -> plus  #get; #get { OPUN^sym = "+"; }
OPUN -> minus #get; #get { OPUN^sym = "-"; }
OPUN -> not   #get; #get { OPUN^sym = "!"; }
F -> OPUN F #type;
#type {
    -- TODO:moc: ! with booleans
    if (F1^type.isInt()) {
        F^expr = F^machine.genIntUnaryOp(OPUN^sym, F1^expr);
        F^type = F1^type;
    }
    else {
        error(OP_un_type, F1^type, OPUN^sym);
    }
}

-- new/delete expressions
F -> new opar TYPE cpar #type;
#type {
    if (TYPE^type.isVoid()) {
        error(TYPE_void);
    }
    else {
        F^type = new Pointer(TYPE^type);
        F^expr = F^machine.genNew(TYPE^type);
    }
}

INST -> delete opar E cpar semicolon #gen;
#gen {
    if (E^type.isPointer()) {
        INST^code = INST^machine.genDelete(E^type, E^expr);
    }
    else {
        error(TYPE_unexpected, "pointer", E^type);
    }
    INST^returns = 1;
}

F -> sizeof opar TYPE cpar #type;
#type {
    F^type = new IntegerType();
    if (TYPE^type != null) {
        F^expr = F^machine.genSizeOf(TYPE^type);
    }
}

-- parenthesised expression
F -> opar E cpar #type;
#type {
    F^type = E^type;
    F^expr = F^machine.genParen(E^expr);
}

F -> opar TYPE cpar F #type;
#type {
    if (F1^type != null && !TYPE^type.castsFrom(F1^type)) {
        error(TYPE_unexpected, TYPE^type, F1^type);
    }
    else {
        F^expr = F^machine.genCast(F1^type, TYPE^type, F1^expr);
    }
    F^type = TYPE^type;
}

-- subprogram call
F -> ident opar #types ARGS cpar #gen;
global
    FunctionType fun;
    ArrayList<Expr> exprs;
    boolean ok;
#types {
    Info info = F^symbolTable.globalSearch(ident^txt);
    ok = true;

    if (info == null) {
        error(FUN_unknown, ident^txt);
    }
    else {
        match (info) {
            case InfoFun {
                fun = info.getType();
                F^type = fun.getReturnType();

                ARGS^types = fun.getParameterTypes();
                exprs = new ArrayList<Expr>();
                ARGS^exprs = exprs;
                ARGS^hok = ok;
                ARGS^currIndex = fun.getParameterTypes().iterator();
            }
            default {
                error(FUN_notCallable, ident^txt);
            }
        }
    }
}
#gen {
    if (ARGS^ok && fun != null) {
        F^expr = F^machine.genCall(ident^txt, fun, exprs);
    }
}

F -> ident #type;
#type {
    Info info = F^symbolTable.globalSearch(ident^txt);
    if (info == null) {
        error(VAR_unknown, ident^txt);
    }
    else {
        match (info) {
            case InfoVar {
                F^type = info.getType();
                F^expr = F^machine.genIdent(info);
            }
            default {
                error(VAR_notAVariable, ident^txt);
            }
        }
    }
}

-- pointed-to memory access
F -> mult F #type;
#type {
    match (F1^type) {
        case Pointer {
            F^type = F1^type.getPointee();
            F^expr = F^machine.genDeref(F1^type, F1^expr);
        }
        default {
            error(TYPE_notAPtr, F1^type);
        }
    }
}

-- subprogram call arguments
ARGS -> #types;
#types {
    if (ARGS^currIndex != null && ARGS^currIndex.hasNext()) {
        error(FUN_notEnough);
        ARGS^ok = false;
    }
    else {
        ARGS^ok = true;
    }
}

ARGS -> E #type ARGSX #ok;
#type {
    if (ARGS^currIndex != null) {
        if (!ARGS^currIndex.hasNext()) {
            error(FUN_tooMuch);
            ARGSX^hok = false;
        }
        else {
            Type type = ARGS^currIndex.next();
            if (type.constructsFrom(E^type)) {
                ARGS^exprs.add(ARGS^machine.genCast(E^type, type, E^expr));
                ARGSX^hok = true;
            }
            else {
                error(
                    FUN_wrongParameter,
                    ARGS^currIndex.previousIndex(), type, E^type
                );
                ARGSX^hok = false;
            }
        }
    }

}
#ok {
    ARGS^ok = ARGSX^ok;
}

ARGSX -> #ok;
#ok {
    ARGSX^ok = ARGSX^hok;
}

ARGSX -> comma ARGS #ok;
#ok {
    ARGSX^ok = ARGS^ok;
}

--------------------------------------------------------------------------------
-- MOC stuffs:
--------------------------------------------------------------------------------
-- booleans:
F -> yes #gen;
#gen {
    F^type = new BooleanType();
    F^expr = F^machine.genYes();
}

F -> no #gen;
#gen {
    F^type = new BooleanType();
    F^expr = F^machine.genNo();
}

ENTITIES -> IMPLEMENTATION ENTITIES #gen;
#gen {
    ENTITIES^code = IMPLEMENTATION^code + ENTITIES1^code;
}

-- class definition
IMPLEMENTATION -> class typeident SUPER
                      occbra ATTRIBUTS ccbra
                      METHODS end_ #symbolTable #gen;
global
    ClassType type;
#symbolTable {
    if (IMPLEMENTATION^symbolTable.localSearch(typeident^txt) != null) {
        error(TYPE_exists, typeident^txt);
    }
    else {
        if (IMPLEMENTATION^machine.hasWarning("shadow")
        && IMPLEMENTATION^symbolTable.globalSearch(typeident^txt) != null) {
            warning(WARN_shadow, typeident^txt);
        }

        type = new ClassType(typeident^txt, SUPER^superType);
        IMPLEMENTATION^symbolTable.insertType(typeident^txt, type);
    }
}
#gen {
    IMPLEMENTATION^code = IMPLEMENTATION^machine.genClass(type);
}

-- superclass
SUPER -> #type;
#type {
    SUPER^superType = null;
}

SUPER -> colon typeident #type;
#type {
    Info info = SUPER^symbolTable.localSearch(typeident^txt);
    if (info == null) {
        error(TYPE_unknown, typeident^txt);
    }
    else {
        match (info) {
            case InfoType {
                Type superType = info.getType();
                match (superType) {
                    case ClassType {
                        SUPER^superType = superType;
                    }
                    default {
                        error(CLASS_notAClass, superType);
                    }
                }
            }
            default {
                error(TYPE_notAType, typeident^txt);
            }
        }
    }
}

--attributes
ATTRIBUTS -> ;
-- ATTRIBUTS -> TYPE ident semicolon ATTRIBUTS;

-- methods
METHODS -> ;

--METHODS -> METHOD  METHODS;
--METHOD -> QUAL PTYPE   MFUNC_PARAMETERS BLOCK;
-- --method or attribute qualifier: + = class, - = instance
--QUAL -> plus;
--QUAL -> minus;
-- --type class
--STYPE-> typeident;
-- -- type "any"
--TYPE -> id;
---- method return type between parens
--PTYPE-> opar TYPE cpar;
---- method parameters
--MFUNC_PARAMETERS -> ;
--MFUNC_PARAMETERS -> MFUNC_PARAMETER MFUNC_PARAMETERS;
-- -- selector without parameters
--MFUNC_PARAMETER -> ident;
-- -- selector  + parameter type + parameter name
--MFUNC_PARAMETER -> ident colon  PTYPE ident;
-- -- string MOC (starts with @)
--F -> stringo;
--  --self = Java "this"
--F -> self;
--F -> super;
-- -- method call
--F -> osbra F MARGS csbra;
---- for class method call
--F -> osbra typeident MARGS csbra;
---- method call arguments
--MARGS -> ;
--MARGS -> MARG MARGS;
-- -- selector + arg
--MARG -> ident colon  E;
-- -- selector without arg
--MARG -> ident;
---- --end of MOC extension
